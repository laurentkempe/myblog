---
title: 'Learning AI function calling in C# with Llama 3.2 SLM and Ollama running on your machine'
permalink: /2024/10/28/learning-ai-function-calling-in-csharp-with-llama-32-slm-and-ollama-running-on-your-machine/
date: 10/28/2024 17:22:35
disqusIdentifier: 20241028052235
coverSize: partial
tags: ["C#", "AI", "Ollama", "LLM", "SLM"]
coverCaption: 'Mona Vale, New South Wales, Australia'
coverImage: 'https://live.staticflickr.com/4303/36283818966_6ff2197d3e_h.jpg'
thumbnailImage: 'https://live.staticflickr.com/4303/36283818966_e3fb80e9eb_q.jpg'
---
I've been trying to wrap my head around function/tool calling for a while now, and I'm excited to share what I've learned with you. It's a powerful way to let developers integrate advanced AI features directly into their applications. We'll walk through understanding the core concepts, setting up your environment, and implementing a practical example using a C# source generator.
{/* <!-- more --> */}

# Introduction

AI function calling allows AI models, to interact with external tools or APIs by calling specific functions within their responses. This enables the AI to perform tasks that require real-time data or specific computations, which the model itself cannot directly handle.

For example, an AI model doesn't know anything about the current weather in a specific location or the current time. By calling external functions, the AI can access the necessary data or perform the required computations to provide accurate and up-to-date information.

# Understanding the Core Concepts

When you provide a prompt to the AI model, you can also specify a set of functions that the model can use. The model can decide to generate a structured output that includes the function to call and the necessary parameters.

For example, if you ask for the weather in Illzach, France, and pass a function to get the weather, the model generate an output that includes a call to the weather function with "Illzach, France" as the parameter.
  
```json
{"name": "GetWeather", "parameters": {"city": "Illzach, France"}}
```

# Requirements

To use AI function calling, you typically need:
<br/>
* Supported Models: Ensure the AI model you are using supports function calling
* Function Definitions: Clearly defined functions that the AI can call, including the parameters they require
* Integration Setup: Proper setup to handle the structured output from the AI and make the actual API calls

We will leverage
<br/>
* **Llama 3.2 SLM**, a model supporting function calling
* **C# source generator** to easily define function definitions to pass to the AI model
* **Ollama** to run the SLM and deal with the integration of all

# Setting Up Your Environment

To get started with AI function calling in C#, you need
<br/>
* Install [Ollama](https://www.ollama.com/) to run the SLM and handle the integration
* Pull Llama 3.2 SLM model on your machine `ollama pull llama3.2:3b`

# Implementing a Practical Example

Let's walk through a practical example of AI function calling in C# using a simple time service. We'll define a function that takes a city name as a parameter and returns the current time.

```csharp
string GetCurrentTime(string city) => 
    $"It is {DateTime.Now.Hour}:{DateTime.Now.Minute} in {city}.";
```

We will need to pass a function description to the SLM model. We can use a C# attribute to achieve that goal.

```csharp
[Function("Get the current time for a city")]
public string GetCurrentTime(string city) => 
    $"It is {DateTime.Now.Hour}:{DateTime.Now.Minute} in {city}.";
```

The `Function` attribute will be used by the C# source generator to generate the function description to pass to the SLM model. We need a partial class, so that the other part of the class is generated by the source generator.

```csharp
public sealed partial class Functions
{
    [Function("Get the current time for a city")]
    string GetCurrentTime(string city) =>
        $"It is {DateTime.Now.Hour}:{DateTime.Now.Minute} in {city}.";
}
```

The source generator will generate the following code.

```csharp
partial class Functions
{
    public List<FunctionDetails> GetFunctionDetails() =>
    [
         new("GetCurrentTime", 
            new FunctionParameters("city"), "Get the current time for a city")
    ];
}
```

and it will also generate `FunctionDetails` and `FunctionParameters`

```csharp
public record FunctionDetails(
    [property: JsonPropertyName("name")] string Name,
    [property: JsonPropertyName("parameters")] FunctionParameters FunctionParameters,
    string Description
);

public record FunctionParameters([property: JsonPropertyName("city")] string City);
```

<AlertInfo>
Note that the source generator is not handling the parameter and we currently hardcode the parameter name `city` in the `FunctionParameters` record. I leave that as an exercise for the reader to improve the source generator to handle multiple parameters and their types.
</AlertInfo>

We are now able to provide a prompt to the AI model specifying functions that the model can use. To simplify this, we created `ChatRequestBuilder` allowing to build an OllamaSharp `ChatRequest` with the user prompt, defining the model and the functions.

```csharp
var functions = new Functions();
var request = new ChatRequestBuilder()
    .SetModel("llama3.2:3b")
    .AddMessage(userMessage, "user")
    .AddFunctions(functions)
    .Build();
```

You find the whole source code for `ChatRequestBuilder` in my [aiPlayground](https://github.com/laurentkempe/aiPlayground/) repository.

We can call OllamaSharp Chat API to get the json response from the AI model.

```csharp
var jsonBuilder = new StringBuilder();

// üëáüèº Calling OllamaSharp Chat and getting the response streamed back
var ollamaApiClient = new OllamaApiClient(new Uri("http://localhost:11434"));
await foreach (var responseStream in ollamaApiClient.Chat(request))
{
    jsonBuilder.Append(responseStream?.Message.Content);
}
Console.WriteLine($"User message: {userMessage}");
var json = jsonBuilder.ToString();
Console.WriteLine($"Received from SLM: {json}");
```

It is finally time to parse the json response and call the function.

```csharp
var result = functions.Execute(JsonSerializer.Deserialize<FunctionDetails>(json));
Console.WriteLine($"Function calling result: \"{result}\"");
```

To achieve that we need to add the `Execute` method to the `Functions` class generated using the C# source code generator.

```csharp
partial class Functions
{
    public string Execute(FunctionDetails? function)
    {
        return function?.Name switch 
        {
            "GetCurrentTime" => GetCurrentTime(function.FunctionParameters.City)
        };
    }
    
    public List<FunctionDetails> GetFunctionDetails() =>
    [
        new("GetCurrentTime",
            new FunctionParameters("city"), "Get the current time for a city")
    ];
}
```

Running the application will output the following

```powershell
User message: What time is it in Illzach, France?
Received from SLM: {"name": "GetCurrentTime","parameters": {"city": "Illzach, France"}}
Function calling result: "It is 9:53 in Illzach, France."
```

# Glimpse into the C# source code generator

The source generator is a C# feature that allows you to generate additional C# source files at compile time. It can be used to automate repetitive tasks, reduce boilerplate code, and improve performance by generating code that would otherwise be written manually. In our case, we create a source generator implementing `IIncrementalGenerator`.

First, we need to create the `FunctionAttribute` defining the `Description` of the function to call.

```csharp
private const string Namespace = "Generators";
private const string AttributeName = "FunctionAttribute";

/*lang=cs*/
private const string AttributeSourceCode = 
    $$"""
        // <auto-generated/>

        namespace {{Namespace}}
        {
            [System.AttributeUsage(System.AttributeTargets.Method)]
            public class {{AttributeName}} : System.Attribute
            {
                public string Description { get; }
        
                public FunctionAttribute(string description)
                {
                    Description = description;
                }
            }
        }
        """;
```

and a method generating a new source file `FunctionAttribute.g.cs` with the `FunctionAttribute` source code.

```csharp
private static void AddMarkerAttributeToCompilation(IncrementalGeneratorInitializationContext context) 
{
    context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
        "FunctionAttribute.g.cs",
        SourceText.From(AttributeSourceCode, Encoding.UTF8)));
}
```

We do the same for `FunctionDetails` and `FunctionParameters` records.

```csharp
/*lang=cs*/
private const string FunctionDetailsSourceCode = 
    $$"""
        // <auto-generated/>

        namespace {{Namespace}}
        {
            public record FunctionDetails(
                [property: JsonPropertyName("name")] string Name,
                [property: JsonPropertyName("parameters")] FunctionParameters FunctionParameters,
                string Description
            );
        }
        """;

/*lang=cs*/
private const string FunctionParametersSourceCode = 
    $$"""
        // <auto-generated/>

        namespace {{Namespace}}
        {
        public record FunctionParameters([property: JsonPropertyName("city")] string City);
        }
        """;

private static void AddFunctionDetailsToCompilation(IncrementalGeneratorInitializationContext context)
{
    context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
        "FunctionDetails.g.cs",
        SourceText.From(FunctionDetailsSourceCode, Encoding.UTF8)));
}

private static void AddFunctionParametersToCompilation(IncrementalGeneratorInitializationContext context)  
{
    context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
        "FunctionParameters.g.cs",
        SourceText.From(FunctionParametersSourceCode, Encoding.UTF8)));
}
```
                                                          
It is time to implement `void Initialize(IncrementalGeneratorInitializationContext context)` from `IIncrementalGenerator` interface. It will add the `FunctionAttribute`, `FunctionDetails`, and `FunctionParameters` to the compilation. Then it will get all methods decorated with the `FunctionAttribute` and generate the source code.

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    AddMarkerAttributeToCompilation(context);
    AddFunctionDetailsToCompilation(context);
    AddFunctionParametersToCompilation(context);

    // üëáüèº Filter classes annotated with the [Function] attribute. Only filtered Syntax Nodes can trigger code generation.  
    var provider = context.SyntaxProvider
        .CreateSyntaxProvider(
            (s, _) => s is MethodDeclarationSyntax,
            (ctx, _) => GetMethodDeclarationForSourceGen(ctx))
        .Where(t => t.functionAttributeFound)
        .Select((t, _) => t.Item1);

    // üëáüèº Generate the source code.
    context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
        (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
}
```

We need to find the `MethodDeclarationSyntax` decorated with the `FunctionAttribute`.

```csharp
    private static (MethodDeclarationSyntax, bool functionAttributeFound) GetMethodDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;

        // üëáüèº Go through all attributes of the class.
        foreach (var attributeListSyntax in methodDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)  
                continue; // if we can't get the symbol, ignore it

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // üëáüèº Check the full name of the [Function] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (methodDeclarationSyntax, true);
        }

        return (methodDeclarationSyntax, false);
    }
```

Finally, we generate the source code for the partial `Functions` class.

```csharp
private static void GenerateCode(SourceProductionContext context,
                                 ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
{
    var partialClassName = "";
    if (methodDeclarations.First().Parent is ClassDeclarationSyntax classDeclarationSyntax)
        partialClassName = classDeclarationSyntax.Identifier.Text;

    var (functionNamePatternMatching, functionDetails) =
        GenerateFunctionDetails(methodDeclarations);

    /*lang=cs*/
    var partialClassCode =
        $$$"""
            // <auto-generated/>

            using System;
            using System.Collections.Generic;

            partial class {{{partialClassName}}}
            {
                public string Execute(FunctionDetails? function)
                {
                    return function?.Name switch 
                    {
                        {{{functionNamePatternMatching}}}
                    };
                }
                
                public List<FunctionDetails> GetFunctionDetails() =>
                [
                    {{{functionDetails}}}
                ];
            }
            """;

    // Add the source code to the compilation.
    context.AddSource($"{partialClassName}.g.cs", 
                      SourceText.From(partialClassCode, Encoding.UTF8));
}
```

To generate the code we need to extract the function descriptions and names.

```csharp	
private static List<(string name, string description)> ExtractFunctionDescriptions(
    ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
{
    var functionNames = new List<(string name, string description)>();

    // Go through all filtered method declarations.
    foreach (var methodDeclarationSyntax in methodDeclarations)
    {
        // üëáüèº Get attribute property called Function from methodDeclarationSyntax
        var attributeSyntax = methodDeclarationSyntax.AttributeLists
            .SelectMany(x => x.Attributes)
            .First(x => x.Name.ToString() == "Function");

        var descriptionArgument = attributeSyntax.ArgumentList?.Arguments.First();
        if (descriptionArgument == null) continue;
        
        // üëáüèº Get attribute Description property
        var descriptionLiteral = (LiteralExpressionSyntax)descriptionArgument.Expression;
        var descriptionValue = descriptionLiteral.Token.ValueText;

        functionNames.Add(
            new ValueTuple<string, string>(methodDeclarationSyntax.Identifier.Text, descriptionValue));
    }

    return functionNames;
}
```

And create the function details and function name pattern matching.

```csharp
private static (StringBuilder functionNamePatternMatching, StringBuilder functionDetails) GenerateFunctionDetails(
    ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
{
    StringBuilder functionNamePatternMatching = new();
    StringBuilder functionDetails = new();

    List<(string name, string description)> functionNames = ExtractFunctionDescriptions(methodDeclarations); 
    
    for (var i = 0; i < functionNames.Count; i++)
    {
        var functionNamesIndex = functionNames.Count - 1;
        var separator = i < functionNamesIndex ? "," : "";
        var indentFunctionName = i < functionNamesIndex ? "" : "             ";
        var indentFunctionDetails = i < functionNamesIndex ? "" : "        ";
        var newLine = i < functionNamesIndex ? "\n" : "";
        functionNamePatternMatching.Append(
            $"{indentFunctionName}\"{functionNames[i].name}\" => {functionNames[i].name}(function.FunctionParameters.City){separator}{newLine}");  
        functionDetails.Append(
            $"{indentFunctionDetails}new(\"{functionNames[i].name}\", new FunctionParameters(\"city\"), \"{functionNames[i].description}\"){separator}{newLine}");  
    }

    return (functionNamePatternMatching, functionDetails);
}
```

# Result

From our function declaration

```csharp
// üëáüèº Partial class annotated with the [Function] attribute used to generate functions.
public sealed partial class Functions
{
    [Function("Get the current time for a city")]
    string GetCurrentTime(string city) =>
        $"It is {DateTime.Now.Hour}:{DateTime.Now.Minute} in {city}.";

    [Function("Get the current weather for a city")]
    string GetCurrentWeather(string city) =>
        "The weather in " + city + " is sunny.";
}
```

We generate the following code

```csharp
// <auto-generated/>

using System;
using System.Collections.Generic;

partial class Functions
{
    public string Execute(FunctionDetails? function)
    {
        return function?.Name switch 
        {
             "GetCurrentTime" => GetCurrentTime(function.FunctionParameters.City),
             "GetCurrentWeather" => GetCurrentWeather(function.FunctionParameters.City)
        };
    }
    
    public List<FunctionDetails> GetFunctionDetails() =>
    [
        new("GetCurrentTime", new FunctionParameters("city"), "Get the current time for a city"),
        new("GetCurrentWeather", new FunctionParameters("city"), "Get the current weather for a city")  
    ];
}
```

# Conclusion

AI function/tool calling is a powerful tool that allows AI models to interact with external tools and APIs, enabling them to perform complex tasks that require real-time data or specific computations. By understanding the core concepts and setting up your environment correctly, you can easily integrate AI-driven functionality into your C# projects, enhancing their capabilities.

I hope this tutorial has provided you with a clear understanding of AI function calling in C# and how you can get started with it.

# References

* [OllamaSharp](https://github.com/awaescher/OllamaSharp)
* [Ollama](https://www.ollama.com/)
* [Ollama Tool support](https://www.ollama.com/blog/tool-support)
* [Llama 3.2 SLM](https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/)
* [Creating an incremental generator](https://andrewlock.net/creating-a-source-generator-part-1-creating-an-incremental-source-generator/)
* [Developing Source Generators in C#](https://www.pluralsight.com/courses/c-sharp-10-developing-source-generators)

Get the source code on GitHub [laurentkempe/aiPlayground/OllamaToolConsoleApp](https://github.com/laurentkempe/aiPlayground/tree/main/OllamaToolConsoleApp).

<p></p>
<GitHubCard user="laurentkempe" repo="aiPlayground" align="left" />

