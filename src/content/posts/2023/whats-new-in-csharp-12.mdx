---
title: 'What''s new in C# 12'
permalink: /2023/11/14/whats-new-in-csharp-12/
date: 11/14/2023 17:00:00
disqusIdentifier: 20231114050000
coverSize: partial
tags: [C#]
coverCaption: 'Moʻorea, Polynésie, France'
coverImage: 'https://live.staticflickr.com/4414/37037178015_ecc08d8531_h.jpg'
thumbnailImage: 'https://live.staticflickr.com/4414/37037178015_05d65d99ca_q.jpg'
---
C# 12 is the latest, just released, version of the popular programming language that runs on the .NET 8 platform. It introduces several new features that aim to improve the expressiveness, performance, and safety of the language. In this post, we will explore some of these features and see how they can benefit your code.
{/* <!-- more --> */}


# Every day C# 12 features

Those features might be used every day by developers adopting C# 12.

## Primary constructors

Primary constructors allow you to **declare parameters for a class or struct in the same line as the type name**. These parameters are in scope for the entire body of the type, and can be used to initialize fields, properties, or methods. For example:

```csharp
class Student(string name, int score)
{
    public string Name => name;
    public int Score => score;
    public void Greet() => Console.WriteLine($"Hello, {name}!");
}
```

Primary constructors were previously available for record types, which are immutable types that support value equality and deconstruction. Record types can also use positional syntax to declare primary constructor parameters and public properties in one line. For example:

```csharp
record Point(int X, int Y);
```

<Alert mode="warning">
Public properties for primary constructor parameters are generated by the compiler only in record types, which can be either record class or record struct types.
</Alert>

## Collection expressions

Collection expressions are a **new syntax to create collections of elements**, such as arrays, `System.Span<T>` and `System.ReadOnlySpan<T>`, or types supporting collection initializer like `List<T>`. You can use the spread operator `..` to inline other collections into a collection expression. For example:

```csharp
int[] someOtherNumbers = [4, 5, 6];
List<int> numbers = [1, 2, 3, ..someOtherNumbers, 7, 8, 9];

string[] moreFruits = ["orange", "pear"];
IEnumerable<string> fruits = ["apple", "banana", "cherry", ..moreFruits];

List<(string, int)> otherScores = [("Dave", 90), ("Bob", 80)];
(string name, int score)[] scores = [("Alice", 90), ..otherScores, ("Charlie", 70)];

Student[] students = [new Student("Alice", 90), new Student("Bob", 80)];

Span<char> span = ['h', 'e', 'l', 'l', 'o' ];
```

Collection expressions can be used anywhere you need a collection of elements, such as initializing a field, passing an argument, or returning a value.

## Optional parameters in lambda expressions

You can now **define default values for parameters in lambda expressions**, just like you can for methods or local functions. This can make your code more concise and flexible when using delegates or functional programming patterns. For example:

```csharp
var incrementBy = (int source, int increment = 1) => source + increment;
Console.WriteLine(incrementBy(2)); // prints 3
Console.WriteLine(incrementBy(2, 3)); // prints 5
```

## Alias any type

You can now **use the `using` directive to create aliases for any type**, not just named types. This can be useful for creating semantic aliases for complex types, such as tuples, arrays, pointers, or other unsafe types. For example:

```csharp
using Point = (int X, int Y);
Point p = (3, 4);

using Matrix = int[][];
Matrix aMatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```

# Advanced C# 12 features

Those features will be used mostly in advanced scenario of C# 12.

## ref readonly parameters

You can now **use the `ref readonly` modifier on parameters** to indicate that they are passed by reference, but cannot be modified. This can improve the performance of your code by avoiding unnecessary copying, and also enforce the immutability of the arguments. For example:

```csharp
var one = 1;
var two = 2;

var max = Max(ref one, ref two);

static ref readonly int Max(ref readonly int x, ref readonly int y) 
    => ref x > y ? ref x : ref y;
```

## Inline arrays

Inline arrays are a way to **create an array of fixed size in a struct type, without using unsafe code** or fixed size buffers. Inline arrays can improve the performance of your code by reducing allocations and copying. For example:

```csharp
// Indicates that the instance's storage is sequentially replicated Length times.
[System.Runtime.CompilerServices.InlineArray(5)]
public struct Buffer
{
    private int _element0;
}

var buffer = new Buffer();
for (int i = 0; i < 5; i++)
{
    buffer[i] = i;
}
```

Inline arrays are mainly used by the runtime team and other library authors to implement types such as `Span<T>` or `ReadOnlySpan<T>`, which are used to represent slices of memory.

# Experimental attribute

You can now **mark types, methods, or assemblies with the `ExperimentalAttribute` to indicate that they are experimental features** that may change or be removed in the future. The compiler will issue a warning if you access a member that is marked with this attribute. For example:

```csharp
[Experimental]
class Foo
{
    [Experimental]
    public void Bar() { }
}

class Program
{
    static void Main()
    {
        var foo = new Foo(); // warning: 'Foo' is experimental
        foo.Bar(); // warning: 'Foo.Bar()' is experimental
    }
}
```

# Interceptors

Interceptors are an experimental feature that **allow you to substitute a call to a method with a call to another method at compile time**. This can be useful for modifying the semantics of existing code by adding new code to a compilation, for example in a source generator.

To use interceptors, you need to enable the `InterceptorsPreview` feature flag in your project file. 

<Alert mode="warning">
Interceptors are still in preview mode and may be subject to breaking changes or removal in a future release.
</Alert>

# Conclusion

These are the new features of C# 12 that you can start to use now. You can learn more about these features and other improvements in C# 12 by reading the official documentation or the feature specifications. Happy coding!

# References

* [What's new in C# 12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12)
* [Primary constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors)
* [Collection expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions)
* [Optional parameters in lambda expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression)
* [Alias any type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/using-alias-types)
* [ref readonly parameters](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/ref-readonly-parameters)
* [Inline arrays](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#inline-arrays)
* [Experimental attribute](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/experimental-attribute)
* [Interceptors](https://github.com/dotnet/roslyn/blob/main/docs/features/interceptors.md)
